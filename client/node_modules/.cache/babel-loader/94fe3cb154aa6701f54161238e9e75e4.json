{"ast":null,"code":"(function () {\n  var Radar = {\n    //regexLine : /<line.*?x1=\"([\\d\\.]*?)\".*?y1=\"([\\d\\.]*?)\".*?x2=\"([\\d\\.]*?)\".*?y2=\"([\\d\\.]*?)\".*?>/gi;\n    //newline : '<line x1=\"$1\" y1=\"$2\" x2=\"$3\" y2=\"$4\"/>';\n    options: {\n      viewBox: '0,0,610,610',\n      preserveAspectRatio: \"none\",\n      chart: {\n        width: '100%',\n        height: '100%'\n      },\n      isDonut: true,\n      //中心點是否摟空\n      centerRadius: 20,\n      //中心點空白偏移量\n      levels: 5,\n      //橫軸層數\n      verticalAxis: {\n        show: true,\n        css: 'vertical-axis'\n      },\n      //縱軸線\n      horizontalAxis: {\n        show: true,\n        css: 'horizontal-axis'\n      },\n      //橫軸線\n      verticalZoom: 0.8,\n      //縱軸縮放 （縱軸padding功用)\n      maxValue: 100,\n      //縱軸上的最大值\n      minValue: 0,\n      //縱軸上的最小值\n      scale: 10,\n      //縱軸刻度數\n      scaleText: '',\n      scaleShow: true,\n      scaleColor: 'black',\n      scaleWidth: 2,\n      scaleFontSize: 14,\n      showTitle: true,\n      //項目標題\n      placement: {\n        show: true,\n        type: 'circle',\n        radius: 7\n      },\n      //項目放置點 {type:'rect', width:10, height:10}\n      //panel\n      infoPanel: {\n        show: true,\n        width: 70,\n        height: 24\n      },\n      //資訊板\n      infoPanelRadius: {\n        rx: 5,\n        ry: 5\n      },\n      //圓角\n      infoPanelGap: {\n        h: 10,\n        v: 10\n      },\n      infoPadding: {\n        left: 3,\n        top: 4\n      },\n      //\n      arc: 2 * Math.PI,\n      //圓弧\n      areaShow: true,\n      //是否顯示一個項目的區塊\n      color: d3.scale.category10(),\n      horizontalDashEnable: true,\n      //是否呈現虛線\n      verticalDashEnable: true,\n      itemTitleGap: 6,\n      //縱軸上的標題間隔\n      surmiseFontGap: 3,\n      //假設的font gap\n      isDebug: false //除錯模式才會把 例外丟出\n\n    },\n    mixOptions: function (options) {\n      var opt = Object.create(this.options);\n\n      if (options != null) {\n        for (var attr in options) {\n          opt[attr] = options[attr];\n        }\n      }\n\n      return opt;\n    },\n    reset: function (id) {\n      d3.select(id).select('svg').remove();\n    },\n    //利用三角函式計算坐標點\n    getPoint: function (radius, radians, offset) {\n      return {\n        x: radius * -Math.sin(radians) + offset,\n        y: radius * -Math.cos(radians) + offset\n      };\n    },\n    //繪製刻度表\n    drawScaleLine: function (svg, verticalLength, onePiece, minLength, opt, self) {\n      if (opt.scaleShow) {\n        var p1 = self.getPoint(verticalLength, 0, minLength);\n        var p2 = self.getPoint(opt.centerRadius, 0, minLength);\n        var basicLength = (p2.y - p1.y) / opt.levels;\n        var basicValue = (opt.maxValue - opt.minValue) / opt.levels;\n        /*\n        svg.append('g').attr('class','scale-group')\n           .append('line')\n           .attr('x1', p1.x)\n           .attr('y1', p1.y)\n           .attr('x2', p2.x)\n           .attr('y2', p2.y)\n           .attr('stroke', opt.scaleColor )\n           .attr('stroke-width', opt.scaleWidth);\n         */\n\n        var g = svg.append('g').attr('class', 'scale-group');\n\n        for (var j = 0, count = opt.levels; j <= count; j++) {\n          var textY = p2.y - j * basicLength;\n          g.append('text').attr('x', p1.x).attr('y', textY).attr('fill', opt.scaleColor).attr('font-size', opt.scaleFontSize + 'px').text(j * basicValue + opt.scaleText);\n        }\n      }\n    },\n    //繪製橫軸\n    drawHorizontalAxis: function (svg, index, onePiece, minLength, radius, group, self) {\n      var p1 = self.getPoint(radius, onePiece * index, minLength);\n      var p2 = self.getPoint(radius, onePiece * (index + 1), minLength);\n      var line = group.append('line');\n      var css = self.options.horizontalDashEnable ? 'horizontal-axis dash' : 'horizontal-axis';\n      line.attr('class', css).attr('x1', p1.x).attr('y1', p1.y).attr('x2', p2.x).attr('y2', p2.y);\n    },\n    //繪製橫軸網\n    drawHorizontalWeb: function (svg, show, onePiece, minLength, verticalLength, count, opt, self) {\n      if (show) {\n        var horizontalAxisGap = verticalLength / opt.levels;\n\n        for (var outIndex = 0; outIndex <= opt.levels; outIndex++) {\n          var group = svg.append('g').attr('class', 'horizontal-web');\n          var radius = outIndex * horizontalAxisGap + opt.centerRadius;\n\n          for (var index = 0; index < count; index++) {\n            svg.call(self.drawHorizontalAxis, index, onePiece, minLength, radius, group, self);\n          }\n        }\n      }\n    },\n    //繪製縱軸\n    drawVerticalAxis: function (svg, p1, p2, group, self) {\n      var line = group.append('line');\n      var css = self.options.verticalDashEnable ? ' vertical-axis dash' : 'vertical-axis';\n      line.attr('class', css).attr('x1', p1.x).attr('y1', p1.y).attr('x2', p2.x).attr('y2', p2.y);\n    },\n    //繪製軸上的標題\n    drawItemTitle: function (svg, p1, p2, title, group, minLength, opt, self) {\n      //minLength 就是矩行的中心點位置\n      var x = Math.ceil(p1.x);\n      var y = Math.ceil(p1.y);\n      var text = group.append('text').attr('class', 'item-title').text(title);\n      var fontSize = text.style(\"font-size\").replace('pt', '').replace('px', '') | 0;\n      var gapTotal = opt.surmiseFontGap * (title.length - 1);\n      var offsetW = fontSize * title.length + gapTotal; //\n\n      var offsetH = fontSize / 2 | 0; //x is rigth\n\n      if (x > minLength) {\n        text.attr('x', p1.x + opt.itemTitleGap);\n      } else if (x < minLength) {\n        text.attr('x', p1.x - opt.itemTitleGap - offsetW);\n      } else {\n        //x is center\n        text.attr('x', p1.x - offsetW / 2);\n      }\n\n      if (y > minLength) {\n        text.attr('y', p1.y + offsetH + opt.itemTitleGap + 5);\n      } else if (y < minLength) {\n        text.attr('y', p1.y - offsetH - opt.itemTitleGap);\n      } else {\n        text.attr('y', p1.y);\n      }\n    },\n    //繪製縱軸網\n    drawVerticalWeb: function (svg, show, onePiece, minLength, verticalLength, count, opt, self) {\n      if (show) {\n        var axixGroup = svg.append('g').attr('class', 'vertical-web');\n        var titleGroup = svg.append('g').attr('class', 'title-group');\n        var titleList = svg.datum()[0];\n\n        for (var index = 0; index < count; index++) {\n          var currentRadians = onePiece * index; //當前縱軸的弧度\n\n          var p1 = self.getPoint(verticalLength, currentRadians, minLength);\n          var p2 = self.getPoint(opt.centerRadius, currentRadians, minLength);\n          var title = titleList[index].title;\n          svg.call(self.drawVerticalAxis, p1, p2, axixGroup, self);\n          svg.call(self.drawItemTitle, p1, p2, title, titleGroup, minLength, opt, self);\n        }\n      }\n    },\n    //計算出所有值得落點\n    getPoinst: function (svg, onePiece, minLength, centerRadius, opt, self) {\n      var pointList = {\n        areaPoints: [],\n        pointPoints: []\n      };\n      var areaCount = svg.datum().length;\n\n      for (var outIndex = 0; outIndex < areaCount; outIndex++) {\n        pointList.pointPoints[outIndex] = [];\n        var areaData = svg.datum()[outIndex];\n        var points = '';\n\n        for (var index = 0, valueCount = areaData.length; index < valueCount; index++) {\n          var val = areaData[index].value; //var radius = (minLength-centerRadius )/ (opt.maxValue - opt.minValue) * val + centerRadius;\n\n          var radius = minLength * opt.verticalZoom / (opt.maxValue - opt.minValue) * val + centerRadius;\n          var point = self.getPoint(radius, onePiece * index, minLength);\n          points += point.x + ' ' + point.y + ',';\n          pointList.pointPoints[outIndex].push(point);\n        }\n\n        points = points.substr(0, points.length - 1);\n        pointList.areaPoints.push(points);\n      }\n\n      return pointList;\n    },\n    areaMouseOver: function (data) {\n      var areaGroup = d3.select('.area-box').selectAll('.area-group');\n      var areas = areaGroup.selectAll('.area'); //var marks = areaGroup.selectAll('.mark');\n\n      var currentArea = d3.select(this).select('.area'); //var currentMarks = d3.select(this).selectAll('.mark');\n\n      areas.classed('areaFade', true); //marks.classed('areaFade', true);\n\n      currentArea.classed('areaFade', false).classed('areaHover', true); //currentMarks.classed('areaFade', false);//.classed('areaHover', true);\n    },\n    areaMouseOut: function (data) {\n      d3.select('.area-box').selectAll('.area-group').selectAll('.area').classed('areaFade', false);\n      d3.select(this).select('.area').classed('areaHover', false); //d3.select('.area-box').selectAll('.area-group').selectAll('.mark').classed('areaFade', false);\n    },\n    //繪製區域\n    drawArea: function (svg, show, areaPoints, opt, self) {\n      var areaBox = svg.append('g').attr('class', 'area-box');\n\n      if (show) {\n        for (var i = 0, l = areaPoints.length; i < l; i++) {\n          var areaGrup = areaBox.append('g').attr('class', 'area-group');\n          var area = areaGrup.append('polygon');\n          area.attr('class', 'area').attr('points', areaPoints[i]).style('fill', opt.color(i)).style('stroke', opt.color(i));\n          areaGrup.on('mouseover', self.areaMouseOver);\n          areaGrup.on('mouseout', self.areaMouseOut);\n        }\n      }\n    },\n    markMouseOver: function (data) {\n      var self = this.self;\n      var target = d3.select(this);\n      var x = Number(target.attr('cx'));\n      var y = Number(target.attr('cy'));\n      var gap = self.options.infoPanelGap;\n      var padding = self.options.infoPadding;\n      var viewBoxList = self.options.viewBox.split(',');\n      var w = viewBoxList[2];\n      var h = viewBoxList[3];\n      var panelX = 0;\n\n      if (x + gap.h + self.options.infoPanel.width > w) {\n        panelX = x - gap.h - self.options.infoPanel.width;\n        panelTitleX = x - gap.h + padding.top - self.options.infoPanel.width;\n      } else {\n        panelX = x + gap.h;\n        panelTitleX = x + gap.h + padding.top;\n      }\n\n      self.panel.classed('panel-show', true).attr('x', panelX).attr('y', y + gap.v);\n      self.panelTitle.classed('panel-show', true).attr('x', panelTitleX).attr('y', y + gap.v + 14 + padding.left).text(data.title + ':' + data.showValue);\n    },\n    markMouseOut: function (data) {\n      var self = this.self;\n      self.panel.classed('panel-show', false);\n      self.panelTitle.classed('panel-show', false);\n      self.panelTitle.text('');\n    },\n    //標記分數\n    drawMark: function (svg, points, opt, self) {\n      var gulps = svg.selectAll('.area-group')[0];\n      var dataList = svg.datum();\n\n      for (var groupIndex = 0, count = points.length; groupIndex < count; groupIndex++) {\n        var gulp = d3.select(gulps[groupIndex]); //這是跟區域同一圖層\n\n        var markPoints = points[groupIndex];\n        var dataItem = dataList[groupIndex];\n\n        for (var markIndex = 0, l = markPoints.length; markIndex < l; markIndex++) {\n          var obj = dataItem[markIndex];\n          var p = markPoints[markIndex];\n          var mark = gulp.append(opt.placement.type);\n          mark.attr('class', 'mark');\n          mark.attr('cx', p.x).attr('cy', p.y).attr('r', opt.placement.radius);\n          mark.style('fill', opt.color(groupIndex));\n          mark.datum(obj); //bind data\n\n          mark[0][0].self = self; //bind self\n\n          mark.on('mouseover', self.markMouseOver);\n          mark.on('mouseout', self.markMouseOut);\n        }\n      }\n    },\n    panel: null,\n    panelTitle: null,\n    //panelText : null,\n    drawInfoPanel: function (svg, opt, self) {\n      var w = opt.infoPanel.width;\n      var h = opt.infoPanel.height;\n      var panelGroup = svg.append('g').attr('class', 'infoPanel-group');\n      self.panel = panelGroup.append('rect').attr('class', 'infoPanel').attr('width', w).attr('height', h).attr('x', 0).attr('y', 0).attr('rx', opt.infoPanelRadius.rx).attr('ry', opt.infoPanelRadius.ry);\n      self.panelTitle = panelGroup.append('text').attr('class', 'panel-title'); // self.panelText = panelGroup.append('text').attr('class', 'panel-text');\n    },\n    renderRadar: function (svg, opt, self) {\n      var total = svg.datum()[0].length;\n      var onePiece = opt.arc / total; //一條直軸所占的弧\n\n      var viewBoxList = opt.viewBox.split(',');\n      var w = viewBoxList[2];\n      var h = viewBoxList[3]; //var minLength = Math.min(svg.property('clientHeight') / 2, svg.property('clientWidth') / 2); //矩形的最小邊 / 2\n\n      var minLength = Math.min(h / 2, w / 2);\n      var verticalLength = opt.verticalZoom * minLength; // - opt.centerRadius;\t\t//縱軸長度\n\n      var pointsList = self.getPoinst(svg, onePiece, minLength, opt.centerRadius, opt, self); //計算出落點坐標\n      //reander horizontal axis\n\n      svg.call(self.drawHorizontalWeb, opt.horizontalAxis.show, onePiece, minLength, verticalLength, total, opt, self); //render vertical axis\n\n      svg.call(self.drawVerticalWeb, opt.verticalAxis.show, onePiece, minLength, verticalLength + opt.centerRadius, total, opt, self); //繪製刻度\n\n      svg.call(self.drawScaleLine, verticalLength + opt.centerRadius, onePiece, minLength, opt, self); //reander area\n\n      svg.call(self.drawArea, opt.areaShow, pointsList.areaPoints, opt, self); //rander mark\n\n      svg.call(self.drawMark, pointsList.pointPoints, opt, self); //rander info panel\n\n      svg.call(self.drawInfoPanel, opt, self);\n    },\n    draw: function (id, data, options) {\n      try {\n        this.reset(id);\n        var opt = options ? this.mixOptions(options) : this.mixOptions(null);\n        var svg = d3.select(id).append(\"svg\");\n        svg.attr('class', 'radar');\n        svg.attr(\"width\", opt.chart.width);\n        svg.attr(\"height\", opt.chart.height);\n        svg.attr(\"viewBox\", opt.viewBox);\n        svg.attr(\"preserveAspectRatio\", opt.preserveAspectRatio);\n        svg.datum(data); //塞入數據\n\n        svg.call(this.renderRadar, opt, this); //要呼叫的函數 (會先執行)\n      } catch (e) {\n        if (opt.isDebug) throw e;\n      }\n    }\n  };\n\n  if (!window.Radar) {\n    window.Radar = Radar;\n  }\n\n  if (typeof module != \"undefined\") {\n    module.exports = Radar;\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}